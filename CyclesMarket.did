type definite_canister_settings = 
 record {
   compute_allocation: nat;
   controllers: vec principal;
   freezing_threshold: nat;
   memory_allocation: nat;
 };
type canister_status = 
 record {
   cycles: nat;
   memory_size: nat;
   module_hash: opt vec nat8;
   settings: definite_canister_settings;
   status: variant {
             running;
             stopped;
             stopping;
           };
 };
type Vol = 
 record {
   swapCyclesVol: CyclesAmount;
   swapIcpVol: IcpE8s;
 };
type TxnResult = 
 variant {
   err:
    record {
      code:
       variant {
         IcpTransferException;
         InsufficientShares;
         NonceError;
         PoolIsEmpty;
         UnacceptableVolatility;
         InvalidCyclesAmout;
         InvalidIcpAmout;
         UndefinedError;
       };
      message: text;
    };
   ok:
    record {
      cycles: BalanceChange;
      icpE8s: BalanceChange;
      shares: ShareChange;
      txid: Txid;
    };
 };
type TxnRecord = 
 record {
   account: AccountId;
   caller: AccountId;
   cyclesWallet: opt CyclesWallet;
   data: opt Data;
   fee: record {
          token0Fee: nat;
          token1Fee: nat;
        };
   index: nat;
   msgCaller: opt principal;
   nonce: Nonce;
   operation: OperationType;
   shares: ShareChange;
   time: Time;
   token0: TokenType;
   token0Value: BalanceChange;
   token1: TokenType;
   token1Value: BalanceChange;
   txid: Txid;
 };
type Txid = blob;
type TransferError = 
 variant {
   BadFee: record {expected_fee: ICP;};
   InsufficientFunds: record {balance: ICP;};
   TxCreatedInFuture;
   TxDuplicate: record {duplicate_of: BlockIndex;};
   TxTooOld: record {allowed_window_nanos: nat64;};
 };
type TokenType = 
 variant {
   Cycles;
   Icp;
   Token: principal;
 };
type Timestamp = nat;
type Time = int;
type Shares = nat;
type ShareWeighted = 
 record {
   shareTimeWeighted: nat;
   updateTime: Timestamp;
 };
type ShareChange = 
 variant {
   Burn: Shares;
   Mint: Shares;
   NoChange;
 };
type Sa = vec nat8;
type PriceWeighted = 
 record {
   cyclesTimeWeighted: nat;
   icpTimeWeighted: nat;
   updateTime: Timestamp;
 };
type OperationType = 
 variant {
   AddLiquidity;
   Claim;
   RemoveLiquidity;
   Swap;
 };
type Nonce = nat;
type Liquidity = 
 record {
   cumulShareWeighted: CumulShareWeighted;
   cycles: nat;
   icpE8s: IcpE8s;
   priceWeighted: PriceWeighted;
   shareWeighted: ShareWeighted;
   shares: Shares;
   swapCount: nat64;
   unitValue: record {
                float64;
                float64;
              };
   vol: Vol;
 };
type IcpE8s = nat;
type ICP = record {e8s: nat64;};
type FeeStatus = 
 record {
   cumulFee: record {
               cyclesBalance: CyclesAmount;
               icpBalance: IcpE8s;
             };
   fee: float64;
   myPortion: opt record {
                    cyclesBalance: CyclesAmount;
                    icpBalance: IcpE8s;
                  };
   totalFee: record {
               cyclesBalance: CyclesAmount;
               icpBalance: IcpE8s;
             };
 };
type Data = blob;
type CyclesWallet = principal;
type CyclesAmount = nat;
type CumulShareWeighted = nat;
type Config = 
 record {
   CYCLES_LIMIT: opt nat;
   FEE: opt nat;
   ICP_FEE: opt nat64;
   ICP_LIMIT: opt nat;
   MAX_CACHE_NUMBER_PER: opt nat;
   MAX_CACHE_TIME: opt nat;
   MAX_STORAGE_TRIES: opt nat;
   MIN_CYCLES: opt nat;
   MIN_ICP_E8S: opt nat;
   STORAGE_CANISTER: opt text;
 };
type BlockIndex = nat64;
type BalanceChange = 
 variant {
   CreditRecord: nat;
   DebitRecord: nat;
   NoChange;
 };
type Address = text;
type AccountId = blob;
type CyclesMarket = service {
   getAccountId: (Address) -> (text) query;
   add: (Address, opt Nonce, opt Data) -> (TxnResult);
   remove: (opt Shares, CyclesWallet, opt Nonce, opt Sa, opt Data) -> (TxnResult);
   cyclesToIcp: (Address, opt Nonce, opt Data) -> (TxnResult);
   icpToCycles: (IcpE8s, CyclesWallet, opt Nonce, opt Sa, opt Data) -> (TxnResult);
   claim: (CyclesWallet, opt Nonce, opt Sa, opt Data) -> (TxnResult);
   count: (opt Address) -> (nat) query;
   canister_status: () -> (canister_status);
   feeStatus: (opt Address) -> (FeeStatus) query;
   getConfig: () -> (Config) query;
   getEvents: (opt Address) -> (vec TxnRecord) query;
   lastTxids: (opt Address) -> (vec Txid) query;
   liquidity: (opt Address) -> (Liquidity) query;
   txnRecord: (Txid) -> (opt TxnRecord) query;
   version: () -> (text) query;
};
service : () -> CyclesMarket
